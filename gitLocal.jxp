<%

if ( request.getHost().equals( "corejs.10gen.com" ) )
    return print( "you can't do this" );

core.git.repo();
core.ext.pluck();
core.content.html();

head.addScript("NOCDN/~~/admin/assets/gitPopup.js");
head.addCSS("NOCDN/~~/admin/assets/gitLocal.css");

var g = new git.Repo(); 

var revid = g.getCurrentRev().parsed.rev;
var revmsg = g.getCommit(revid).parsed.message;
revmsg = revmsg.substring(0, revmsg.indexOf('\n'));

core.admin.pieces.gitHeader({revid: revid, revmsg: revmsg,
                            });

var output_command = function(foo){
    log(tojson(foo));
    print(content.HTML.escape(foo.cmd) + "<br>");
    print("<pre>" + content.HTML.escape(foo.out) + "\n---\n" +
          content.HTML.escape(foo.err) + "</pre>");
    print("<hr>");
};

if ( request.action == "pull" ){
    // No files
    print( "pulling...<br>" );
    var foo = g.pull();
    if(foo.parsed.failed && foo.parsed.failed.conflicts){
        print("Pull failed: conflicts<br/>");
        output_command(foo);
    }
    else if(foo.parsed.failed && foo.parsed.failed.notuptodate) {
        print("Pull failed: uncommitted changes: "+foo.parsed.failed.notuptodate+"<br/>");
        output_command(foo);
    }
    else {
        log(tojson(foo));
        if(foo.parsed.upToDate){
            print("Already up-to-date.");
        }
        else {
            log("from: " + foo.parsed.from + " to: " + foo.parsed.to + " revs: " + tojson(g.listRevs(foo.parsed.from, foo.parsed.to).parsed.revs));
            g.listRevs(foo.parsed.from, foo.parsed.to).parsed.revs.forEach(function(z){ 
                core.admin.pieces.gitPulledrev(z);
            });
        }
    }
}
else if ( request.action == "push" ){
    // No files
    print( "pushing...<br>" );
    var foo = g.push();
    if(foo.parsed.pullFirst){
        output_command(foo);
%>
Push failed. Try pulling first.
        <form method="POST"><input type="submit" name="action" value="pull"></form>
<%
        return;
    }
    else if(foo.parsed.upToDate){
        print("Everything up to date on this branch.");
    }
    else {
        g.listRevs(foo.parsed.from, foo.parsed.to).parsed.revs.forEach(function(z){ 
            core.admin.pieces.gitPushedrev(z);
        });
        g.fetch();
    }
}
else if ( request.action == "add" && request.untracked_file ){
    // Untracked files
    print( "Adding...<br>" );
    var foo = g.add(request.getParameters('untracked_file'));
    output_command(foo);
}
else if ( request.action == "diff" && request.changed_file ){
    // Changed files
    print( "Diffinf...<br>" );
    var foo = g.diff(request.getParameters('changed_file'), {rev: "HEAD"});
    output_command(foo);
}
else if ( request.action == "commit" && request.changed_file ){
    // Changed files
    var showDiff = false;
    if ( ! request.viewedDiff ) showDiff = true;
    else if ( ! request.msg.trim() ){
        print( "need a message!" );
        showDiff = true;
    }

    if ( showDiff ) {
        return core.admin.gitCommit(g);
    }
    else {
	print( "Commit...<br>" );
        
	var foo = g.commit( request.getParameters('changed_file') , request.msg , user );
        output_command(foo);
    }
}
else if ( request.action == "checkout" && request.changed_file ){
    print("Performing checkout...<br>");
    var foo = g.checkout(request.getParameters("changed_file"));
    output_command(foo);
}

if(g.showRef("origin/master").parsed.rev != g.showRef("heads/master").parsed.rev){
    core.admin.pieces.gitNotPushed();
}

var parsed = g.status().parsed;

if(parsed.staged){
    var files = {};
    parsed.staged.forEach(function(z){
        files[z.name] = z.type;
    });

    // If a file is both in staged and changed, remove it from changed
    if(parsed.changed){
        parsed.changed = parsed.changed.filter(function(z){
            return !(files[z.name]);
        });
    }
    parsed.changed = (parsed.changed || []).concat(parsed.staged);
    delete parsed.staged;
}

var conflicts = false;
var unmerged = {};
if(parsed.unmerged){
    parsed.unmerged.forEach(function(z){ unmerged[z.name] = true; });
    delete parsed.unmerged;
    conflicts = true;

    if(parsed.changed){
        var conflictFiles = parsed.changed.filter(function(z){
            if(unmerged[z.name]){
                z.type = "CONFLICT";
                return true;
            }
            return false;
        });
        var otherFiles = parsed.changed.filter(function(z){
            return !(unmerged[z.name]);
        });
        parsed.changed = conflictFiles.concat(otherFiles);
    }
}

var changedbuttons = [{name: 'checkout', disabled: conflicts}, 'commit'];
if(parsed.changed && parsed.changed.length != 1) 
    changedbuttons = ['diff'].concat(changedbuttons);
var buttons = {"changed": changedbuttons, 'untracked': ['add']};

var diffLinks = {"changed": true, 'untracked': false};

var checked = {};
if(request.changed_file)
    request.getParameters('changed_file').forEach(function(z){
        checked[z] = "checked";
    });
if(request.untracked_file)
    request.getParameters('untracked_file').forEach(function(z){
        checked[z] = "checked";
    });

%>
<form method="POST">
<input type="submit" name="action" value="pull" <%= conflicts ? "disabled" : "" %> >
<input type="submit" name="action" value="push"  <%= conflicts ? "disabled" : "" %> >
</form>
<table>
  <form method="POST">
<%
for ( type in parsed ){ 
    core.admin.pieces.gitFileList({title: type, actions: buttons[type],
                                   checked: checked,
                                   unmerged: unmerged, filevar: type+"_file",
                                   filenames: parsed[type].map(Ext.pluck('name')),
                                   filetypes: parsed[type].map(Ext.pluck('type')),
                                   fileDiff: diffLinks[type] });
}
%>
  </form>
</table>

