<% 
// We load this module here, rather than in _shell.jxp, because we "know" that
// this file will always be run first, and because this way it reduces the 
// amount of code that _shell has to run (i.e. improves latency of response.
// Also, we need it here. (oops)
core.admin.data.shellsession();
core.ext.pluck();
core.ext.buffer();

var session = db.shell.sessions.findOne({user: user});
if( ! session ){
    session = new admin.data.ShellSession(user);
    session.save();
}

 %>

<div style="text-align:center;" class="yui-skin-sam">
     Shell (do not refresh page or anything crazy like that)<br>
     <div id="console" class="transcript"></div>
     <div id="treeview"></div>
     <script type="text/javascript" src="/~~/ui/js/compat.js"></script>
     <script type="text/javascript" src="/@@/yui/2.5.1/yuiloader/yuiloader-beta.js"></script>
     <script type="text/javascript">
       var loader = new YAHOO.util.YUILoader();
       loader.insert({
           require: ['fonts', 'dragdrop', 'logger', 'autocomplete', 'treeview', 'json'],
           base: '/@@/yui/2.5.1/',
           onSuccess: function(loader) {
               objectList = [];
               loader.objectTreeView = new YAHOO.widget.TreeView("treeview");
               loader.objectNodes = [];

               var t = document.createElement("textarea");
               t.id = "commandac";
               var commandcontainer = document.createElement("div");
               var acdiv = document.createElement("div");
               prompt = document.createElement("span");
               prompt.className = "prompt";
               prompt.appendChild(document.createTextNode("js> "));
               acdiv.appendChild(prompt);
               acdiv.appendChild(t);
               acdiv.appendChild(commandcontainer);
               this.myLogReader = new YAHOO.widget.LogReader('console', {
                   newestOnTop: false, 
                   footerEnabled: false,
                   _initConsoleEl: function(){
                       YAHOO.widget.LogReader.prototype._initConsoleEl.call(this);
                       this._elBd = this._elConsole;
                       this._elConsole = document.createElement("div");
                       this._elBd.appendChild(this._elConsole);
                       this._elBd.appendChild(acdiv);

                   },
                   _printBuffer: function(){
                       YAHOO.widget.LogReader.prototype._printBuffer.call(this);
                       this._elBd.scrollTop = this._elBd.scrollHeight;
                   }});
               this.myLogReader.setTitle("10gen Shell");

               var sources = this.myLogReader.getSources();
               this.myLogReader.hideSource("global");
               this.myLogReader.hideSource("LogReader");
               this.myLogReader.formatMsg = function(msg){
                   if(msg.category == "format")
                       return msg.msg;

                   if(msg.category == "user"){
                       return "<span class=\"pastprompt\">js&gt;</span> <a class=\"usercmd\">" + msg.msg + "</a><br/>";
                   }
                   if(msg.category == "response"){
                       var string = function(msg){
                           return "<span class=\"response\">" + msg + "</span><br/>";
                       }
                       if(!msg.msg) return "";

                       var s = "";
                       var obj = eval("(" + msg.msg + ")");
                       if(obj.$printed){
                           s += "<span class=\"output\">" + obj.$printed + "</span><br/>";
                       }
                       if(obj.$exception){
                           s += "<span class=\"exception\">" + obj.$exception + "</span><br/>";
                           return s;
                       }
                       
                       obj = obj["$"];
                       if(typeof obj == "object" && obj != null){
                           var i = objectList.push(obj);
                           var treenode = new YAHOO.widget.TextNode("Object " + i,
                               loader.objectTreeView.getRoot(), false);
                           populateTree(treenode, obj);
                           loader.objectNodes.push(treenode);
                           loader.objectTreeView.draw();
                           s += "<span class=\"response\" onclick=\"expandObject("+i+")\">object "+i+"</span><br/>";
                           return s;
                       }
                       else
                           return s += string(YAHOO.lang.JSON.stringify(obj));
                   }
               };
               
               var inputs = <%= tojson(session.getCommands()) %>;

               historyAry = []; // indexes of input used on each line
               pastCommands = []; // commands themselves; unique for YUI AC
               
               // translate non-unique strings into YUI-friendly format
               for(var i = 0; i < inputs.length; i++){
                   var cmd = inputs[i];
                   if(inputs.indexOf(cmd) < i) {
                       // duplicate command!
                   }
                   else {
                       pastCommands.push(cmd);
                   }
                   historyAry.push(pastCommands.indexOf(cmd));
               }

               var outputs = <%= tojson(session.getResults()) %>;

               // re-log all the old commands and responses
               YAHOO.log("<span class='faded'>", "format", "shell");
               for(var i = 0; i < inputs.length; i++){
                   YAHOO.log(inputs[i], 'user', 'shell');
                   YAHOO.log(outputs[i], 'response', 'shell');
               }
               YAHOO.log("</span>", "format", "shell");
               YAHOO.log("<hr/>", "format", "shell");

               this.myLogReader._printBuffer();

               // Install this handler before the autocompleter because it will
               // grab up/down key events
               YAHOO.util.Event.addListener(t,"keydown",blockYUIParen);
               YAHOO.util.Event.addListener(t,"keypress",blockYUIParen);
               YAHOO.util.Event.addListener(t,"keyup",blockYUIParen);

               YAHOO.util.Event.addListener(t,"keydown",histfunc);

               YAHOO.util.Event.addListener("console", "click", 
                                            function(){ t.focus(); });

               // YUI autocomplete tries to autocomplete even if there's been
               // an intervening "Enter" and the input field has been cleared.
               // We block this by keeping a "lastSent"
               // variable with the last complete command we've sent and
               // if we get a query for that exact command, we replace it
               // with a gibberish !!!!!! query.
               YAHOO.util.Event.addListener(t,"keydown",function(e){
                   if(e.keyCode == 13){
                       window.lastSent = encodeURIComponent(t.value);
                       var value = t.value;
                       if(checkRun(t)) {
                           if(value.trim() == "clear" || value.trim() == "clear()" || value.trim() == "__clear()"){
                               doRun(t, "__clear()", "false");
                               location.reload();
                           }
                           doRun(t);
                           e.preventDefault();
                       }
                   }
               });

               // Set up autocompletion stuff
               YAHOO.ACJSArray = new function(){ // Object construction
                   this.oACDS = new YAHOO.widget.DS_JSArray(pastCommands);
                   this.oAutoComp = new YAHOO.widget.AutoComplete(t, commandcontainer, this.oACDS);
                   this.oAutoComp.prehighlightClassName = "yui-ac-prehighlight";
                   this.oAutoComp.typeAhead = true;
                   this.oAutoComp.useShadow = true;
                   this.oAutoComp.minQueryLength = 1;
                   //this.oAutoComp.queryDelay = 0;
                   this.oAutoComp.doBeforeSendQuery = function(q){
                       if(q == window.lastSent){
                           // We only want to throw this away once.
                           // Otherwise the user might type in the exact query
                           // to try to complete a longer query..
                           window.lastSent = "";
                           return "!!!!!!";
                       }
                       return q;
                   };
               };

               historyPopup = new YAHOO.widget.Dialog('history_popup', {
                   fixedcenter: true,
                   draggable: true,
                   visible: false
               });
               historyPopup.render();

               t.focus();

           }
       });

var blockYUIParen = function ( e ) {
    var key = e.keyCode || e.which;
    if(e.shiftKey){
        // In Konqueror and Safari, the keys for lparen and up-arrow generate
        // the same keycode. Because of this, YUI blocks lparen.
        // This is no good, so we block YUI's block by sabotaging the event's
        // preventDefault method.
        restoreDefault(e);
        return;
    }
};

var restoreDefault = function(e){
    e.preventDefault = function(){};
};

// historyLocation starts at 0, and goes negative; -1 is the previous command,
// -2 is the one before that, etc.
// The earliest command is -historyAry.length.
var currentCommand = '';
var historyLocation = 0;

var setHistoryLocation = function( i, cmd ){
    historyLocation = i;
    if(i == 0) {
        setcmd(cmd || "");
    }
    else {
        setcmd();
    }
    var highlit = YAHOO.util.Dom.getElementsByClassName("highlight");
    for(var i = 0; i < highlit.length; i++){
        YAHOO.util.Dom.removeClass(highlit, "highlight");
    }

    highlightHistory();
    
};

var setcmd = function () {
    var cmd = document.getElementById("commandac");
    if ( arguments.length ) {
        cmd.value = arguments[0];
    }
    else {
        cmd.value = pastCommands[historyAry[historyAry.length + historyLocation]];
    }
}

var histfunc = function( e ) {
    var cmd = document.getElementById('commandac').value;
    if(cmd.match(/\n/)){
        restoreDefault(e);
        return;
    }
    if(YAHOO.ACJSArray.oAutoComp.isContainerOpen()) return;
    var key = e.keyCode || e.which;
    if( key == 38 ) { // up arrow
        if(historyLocation == 0)
            currentCommand = document.getElementById("commandac").value;
        historyLocation -= 1;
        if (historyLocation < -historyAry.length){
            historyLocation = -historyAry.length;
        }
        else {
            setHistoryLocation(historyLocation);
        }
    }
    else if( key == 40 ) { // down arrow
        historyLocation += 1;
        if (historyLocation >= 0){
            historyLocation = 0;
            setHistoryLocation(historyLocation, currentCommand);
        }
        else {
            setHistoryLocation(historyLocation);
        }
    }
};
     </script>

     <div class="clear"></div>
     <div onclick="showHistory()">Show history</div>
     <div id="history_popup" style="display: none;">
       <div class="hd">History</div>
       <div class="bd">
         <div id="history_links"><% /* filled in by JS */ %></div>
       </div>
       <div class="ft"></div>
     </div>
</div>

<script>
var count = 0;
var objcount = 0;
function Text(cursor, field){
    return "<input type=\"text\" id=\"txt"+count+"\" value=\""+cursor[field]+"\" onblur=\"rewrite('"+cursor._id+"','"+field+"','"+typeof cursor[field]+"','"+count+"')\">";
}
function Check(cursor, field) {
    return(cursor[field] ? "<input type=\"checkbox\" onclick=\"toggle('"+cursor._id+"','"+field+"',false)\" checked>" : "<input type=\"checkbox\" onclick=\"toggle('"+cursor._id+"','"+field+"',true)\">");
}

function populateTree(treenode, obj) {
    for(var field in obj){
        s = field + ": ";
        if(typeof obj[field] == "boolean") {
            s += obj[field];
        }
        else if(typeof obj[field] == "string") {
            s += '"' + obj[field] + '"';
        }
        else if(typeof obj[field] == "number") {
            s += obj[field];
        }
        else if(typeof obj[field] == "object") {
            s += "Object";
        }
        else {
            s += (typeof obj[field]);
        }

        var tmpNode = new YAHOO.widget.TextNode(s, treenode, false);
        if(typeof obj[field] == "object") {
            populateTree(tmpNode, obj[field]);
        }
    }
}

function expandObj(i){
    loader.objectNodes[i].expand();
}

    indexOf = function(ary, v){
        for(var i=0; i<ary.length; ++i){
            if(ary[i] == v)
                return i;
        }
        return -1;
    };
lastIndexOf = function(ary, v){
    for(var i=ary.length-1; i>=0; --i){
        if(ary[i] == v)
            return i;
    }
    return -1;
};

function checkRun(el){
    var usr = el.value;
    try {
        eval(usr);
    }
    catch(e){
        if(e.toString().match(/SyntaxError/)) return false;
        // We assume that other errors are probably because we're missing stuff
        // client-side that would be there on server-side. So send it over.
    }
    // Either the eval succeeded or the error wasn't syntactic. Either way, OK.
    return true;

    // FIXME: unterminated strings? Should we treat these differently, perhaps
    // not add a newline?

    // This is a more sophisticated approach which might be handy if you want
    // to actually parse the text, but probably not.
    // Strip strings and regexps
    /* OK, so, when checking for [](){}, first strip regexps and quotes.

       "...." and '....' go away.
       "...\"..." go away. So do '...\'...' and '..."...'.

       We don't care what happens in the place of these strings; we're 
       not doing any syntax analysis. For the time being, replace them with 
       the empty string.

       /.../[gim] has to go away.

       Be careful of 12 / 1 + [ 1 / 12 ].

       Also, watch out (as usual) for /..\/../.

       A regular expression can't begin after a number or identifier. So we
       could just look for a pair of slashes and then afterwards post-process
       them to skip any that start after a digit or letter.. except that
       there's no way to get the locations of the matches. So..

       /(\d|\w)\s*\// -> "$"

       HA HA HA

       /\/.*\\\// -> "/$"

       THIS IS HOW WE DO SOPHISTICATED SYNTAX ANALYSIS IN JS

       /\/.+\// -> ""

    */
    // FIXME?: Eliot/Geir say this should be a call to client-side eval(), and
    // we should keep it as long as there's a syntax error.

    var repeat = function(s, f){
        var new_s = s;
        do{
            s = new_s;
            new_s = f(s);
        }while(new_s != s);
        return s;
    }
    var newusr = repeat(usr, function(s) { return s.replace(/'.*?\\'/, "'$"); });
    newusr = repeat(newusr, function(s) { return s.replace(/".*?\\"/, '"$'); });
    newusr = repeat(newusr, function(s) { return s.replace(/\/.*?\\\//, "/$"); });
    // Strip strings
    newusr = newusr.replace(/".*?"/g, '""').replace(/'.*?'/g, '""');

    // Replace / after char or digit (division operator) with nonexistent $ 
    // operator
    newusr = newusr.replace(/(\w|\d)\s*\//g, "$1$");
    // Strip regexes
    newusr = newusr.replace(/\/.*?\/[igm]?/g, "''");

    // simple check right now -- count {/}, [/], (/) and make sure they're equal
    var checkMatch = function(usr, left, right){
        var leftMatch = usr.match(new RegExp(left, "g"));
        if (leftMatch) leftMatch = leftMatch.length;
        else leftMatch = 0;
        var rightMatch = usr.match(new RegExp(right, "g"));
        if (rightMatch) rightMatch = rightMatch.length;
        else rightMatch = 0;
        return leftMatch == rightMatch;
    };
    if(! checkMatch(newusr, "{", "}") ) return false;
    if(! checkMatch(newusr, "\\[", "\\]") ) return false;
    if(! checkMatch(newusr, "\\(", "\\)") ) return false;
    return true;
}

shellId = "shell-" + Math.random();
function doRun(el, value, save){
    var command = el;
    var usr = value || command.value;
    save = save || "";
    command.value = "";
    if(indexOf(pastCommands, usr) == -1){
        // This behavior is inspired by the history functionality in bash.
        // If you retype the last command, or re-run it, it doesn't get
        // entered into the history twice.
        save = "true";
        pastCommands.push(usr);
    }
    if (historyAry.length == 0 || lastIndexOf(historyAry, indexOf(pastCommands, usr)) != historyAry.length-1) {
        historyAry.push(indexOf(pastCommands,usr));
    }

    currentCommand = "";
    setHistoryLocation(0);
    addHistoryLink(historyAry.length-1);

    YAHOO.log(usr, "user", "shell");
    var url = "/admin/_shell?id=" + shellId + "&save="+ save + "&command=" + escape( usr ).replace( /\+/ , "%2B" );

    var res = loadDocSync( url );
    res = res.replace( /(^\s+|\s+$)/g , "" );
    YAHOO.log(res, "response", "shell");

    return false;
}

highlightHistory = function(){
    YAHOO.util.Dom.addClass("historyLink_"+(historyAry.length+historyLocation),
                       "highlight")
};

addHistoryLink = function(i){
    var links = document.getElementById('history_links');
    links.innerHTML = links.innerHTML + makeHistoryLink(i);
};

makeHistoryLink = function(i){
    var cmd = pastCommands[historyAry[i]];
    var divclass = "class='historyLink'";
    var thisdiv = "<div "+divclass+"onclick='activateHistory("+i+")' id='historyLink_"+i+"'>"+i+": "+cmd+"</div>";
    return thisdiv;
};

showHistory = function(){
    var s = "";
    for(var i = 0; i < historyAry.length; i++){
        s += makeHistoryLink(i);
    }
    document.getElementById('history_links').innerHTML = s;
    document.getElementById("history_popup").style.display = "block";
    highlightHistory();

    historyPopup.show();
};

activateHistory = function(i){
    // i goes from 0..n-1.   0 is the earliest.
    // historyLocation goes from -n..-1.   -n is the earliest.
    setHistoryLocation( -(historyAry.length-i) );
    historyPopup.hide();
    document.getElementById( "commandac" ).focus();
};

</script>
